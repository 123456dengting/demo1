学习网站: https://blog.csdn.net/cYang2030/article/details/110727999

# 一.html基础知识
- H5新标签,article,footer,header,nav,section,
- video,audio,
    > audio支持 mp3,wav,ogg格式
- canvas
    > 1.htm5的新特性

    > 2.图形容器

    > 3.通过js绘制

    > 作用

        1.网页游戏
        2.数据可视化-echarts
        3.广告banner的动态效果


- h5的新api,如XMLHttpRequest,Media

# 二.js基础知识
- js类型
- let,const,var
- 字符串方法
- 数组方法
- 对象操作方法
- this指向
- 类型判断
- es6
- Set、Map、WeakSet和WeakMap等
    > Set
    1. 成员不能重复； 
    2. 只有键值，没有键名，有点类似数组； 
    3. 可以遍历，方法有 add、delete、has 
    > WeakSet 
    1. 成员都是对象（引用）； 
    2. 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露； 
    3. 不能遍历，方法有 add、delete、has； 
    > Map
    1. 本质上是键值对的集合，类似集合； 
    2. 可以遍历，方法很多，可以跟各种数据格式转换；
    > WeakMap 
    1. 只接收对象为键名（null 除外），不接受其他类型的值作为键名； 
    2. 键名指向的对象，不计入垃圾回收机制； 
    3. 不能遍历，方法同 get、set、has、delete；

- 存储,localStorage,SessionStorage,cookie,session
- this,bind,apply,call
- 类型判断 typeof  instanceOf Object.prototype.toString.call()
- Promise race,all,final等

- 原型,原型链,继承,类
- 闭包
- 防抖与节流
- eval
- 深度克隆
- 垃圾回收
- defineProperty, Proxy
- get,post,put,delete,options
- 简单说说 js 中有哪几种内存泄露的情况 
    1. 意外的全局变量； 
    2. 闭包； 
    3. 未被清空的定时器； 
    4. 未被销毁的事件监听； 
    5. DOM 引用；

    
# 三.css基础知识
- 居中几种方式
- BFC
- import,以及清除所有样式
- css3新特性

    1. 3个边框属性,border-radius, box-shadow, border-image
    2. background-clip、background-origin、background-size 、background-break
    3. word-wrap 

        normal：使用浏览器默认的换行,
        break-all：允许在单词内换行
    4. 颜色-rgba与hsla
    5. transition: (transition: all 0.5s ease-in-out);

        1. transition-property: width; 
        2. transition-duration: 1s;
        3. transition-timing-function: linear;
        4. transition-delay: 2s;

    6. transform
        1. transform: translate(120px, 50%)：位移
        2. transform: scale(2, 0.5)：缩放
        3. transform: rotate(0.5turn)：旋转
        4. transform: skew(30deg, 20deg)：倾斜

    7. animition

        1. @keyfram moveTranslate{} 帧动画
        2. animation: moveTranslateY3 1s 0s infinite;

    8. linear-gradient


- 浮动
    > 清楚浮动方法
    1. 末尾加标签: clear: both
    2. 父元素: overflow: hidden
    3. 给父元素设置高度
    4. 

- 定位,fixed,absolute,relative,sticky,static
- flex
- gird
- 水平,垂直居中
- px,em,rem,vh,vw
- css引入方式

    1. 行内
    2. 嵌入
    3. link引入
    4. @import引入
    

- link和@import区别
    > 1.link如何加载css还可以加载其他东西,比如标题图等,@import只能加载css
    > 2.link是在页面载入是加载,而@import是页面完全载入后加载,所以开始没样式,闪烁下才有样式
    > 3.link无兼容问题,@import是css2.1提出,低版本浏览器不支持
    > 4.link支持使用js控制dom改变样式,后者不支持
    > 5.
- 盒子模型
    box-sizing 来指定盒模型，分别是:
    content-box: 标准盒模型  ( Element width = width + border + padding)
    border-box；怪异盒模型  ( Element width = width )
- less sass 

# 四.浏览器基础知识
- 跨域
- 常见http请求头
- 网络安全,攻击,防御
- 强缓存,协商缓存
    1. 强缓存分位内存缓存和磁盘缓存
    2. 协商缓存是由服务器决定(成功,304,失败200)
    3. 请求资源优先走强缓存再走协商缓存
- 浏览器不同标签页之间通信(不能使用window,window是在标签页内部)
    > 1.setInterval和cookie

    > 2.websocket

    > 3.localStorage

    > 4.postMessage

    > 4.html5浏览器新特性——SharedWorker
- iframe优缺点

    > iframe优点
    
    1、　iframe能够原封不动地把嵌入的网页展现出来。

    2、　如果有多个网页调用iframe，只需要修改iframe的内容，就可以实现对调用iframe的每一个页面内容的更改，方便快捷。

    3、　网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性。

    4、　如果遇到加载缓慢的第三方内容如图标和广告等，可以用iframe来解决。

    > iframe的缺点：

    1、　会产生很多页面，不容易管理。

    2、　在几个框架中都出现上下、左右滚动条时，这些滚动条除了会挤占已经非常有限的页面空间外，还会分散访问者的注意力。

    3、　使用框架结构时，必须保证正确设置所有的导航链接，否则会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下会导致链接死循环。

    4、　很多的移动设备（PDA手机）无法完全显示框架，设备兼容性差。

    5、　iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。

    > 现在基本上都是用Ajax来代替iframe，iframe已渐渐退出了前端开发。

- 从输入url到页面显示内容的过程

    > 用户输入url

        1.用户输入 url
        2.浏览器进程将该 url 转发给 网络进程
        3.网络进程接收到请求后，先检查本地缓存是否可用，缓存可用则直接读取缓存并返回给浏览器进程；缓存不可用再发起真正的 url 请求。 url 请求过程如下：
            1..DNS 解析，获取服务器 ip地址和端口
            2.与服务端建立 http 连接
            3.构建和发送请求头信息
            4.服务端处理请求后响应请求
            5.浏览器网络进程接收并解析响应内容
        4.浏览器进行分配渲染进程，开始渲染流程。
        5.渲染进程解析 html,并且同时加载异步资源
        6.执行渲染流水线：此时关键资源已经加载完毕，进行浏览器的渲染流水线:
            1.构建 DOM 树
            2.计算 CSSOM 树
            3.计算渲染树 Render Tree(从外而内)
            4.计算布局(重绘,重排,重排一定引起重绘,重绘不一定引起重排)
            5.把每个节点绘制到屏幕上

- tcp,udp
- tcp三次握手
- http1.0 http2.0 https
- 网络模型
        



# 五.vue相关
- 基础语法
- 挂载el和$mount的两种写法
    >el的两种写法
    ```javascript
    const vm = new Vue({
        el: '#root', /第一种写法,直接与容器关联/
        data: {},
    })
    ```
    ```javascript
        const vm = new Vue({
      data: {},
    });
    vm.$mount('#root');  /mount挂载,写法灵活,比如可以加定时器控制执行时间/
    ```
    
    > data的两种写法
    ```javascript
    const vm = new Vue({
        el: '#root',
        data: {},   /第一种写法,对象式/
    })
    ```
    ```javascript
    const vm = new Vue({
        el: '#root',
        data: function(){  /第二种 函数式,function可以省略,组件必须使用函数式/
        return: 'xxx',
        },
    })
    ```
    > 思考：为什么组件中 data 必须使用函数式写法？这个也是一个面试题。

- vue循环中的key作用,和react的key区别

    key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。

    > 虚拟DOM中key的作用：key是虚拟DOM对象的标示，当数据发生变化时，Vue会3据新数据生成新的虚拟DOM，随后Vue进行新虚拟DOM与旧虚拟DOM的差异比较。比较规则如下：

    > 对比规则：❶旧虚拟DOM中找到了与新虚拟DOM相同的key；若虚拟DOM中内容没变，直接使用之前的真实DOM；若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。❷旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到页面。

    > 用index作为key可能会引发的问题：❶若对数据进行：逆序添加、逆序删除破坏操作( 会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低 )。⑵如果结构中还包含输入类的DOM( 会产生错误DOM更新 ==> 界面有问题 )。

    > 开发中如何选择key?

    >最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。❷如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。


- 自定义指令
- spa的理解,以及优缺点

    >SAP 单页面应用，用一句话总结就是整个应用只有一个完整页面，点击页面中的导航只做局部刷新

    >优点： ①用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；②基于上面一点，SPA 相对对服务器压力小；③前后端职责分离，架构清晰。

    >缺点： ①初次加载耗时多；②前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；③SEO 难度较大。


- mvvm模型理解

    > Vue 参考了该 MVVM 模型，在 Vue 之前就有 MVVM 的模型理念。

    > M模型(Model)： 对应data中的数据；V视图(View)： 模板；VM视图模型(ViewModel)： Vue实例对象。

    > 1.data（即M模型）中所有的属性，最后都出现在了vm身上；

    > 2.另外vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用。

- 如何实现双向绑定

    > 其实双向数据绑定分为两种：
    Vue2.x底层语法是 Object.defineProperty()，Vue3.1是Proxy，这个也衍生出他们两个的区别或者说，3.X版本有什么优点，可以自行思考一下。通过这个话题其实可以衍生出 Proxy 与 Object.defineProperty 优劣对比(ES6)语法？与 JavaScript 部分呼应。

- v-model原理

    > 绑定数据并且监听数据改变。v-model 是:value="msg" @input="msg=$event.target.value"的语法糖，其中:value="msg"是绑定了数据，value 就是 input 输入框里的值；@input="msg=$event.target.value"就是监听 input 输入框里值的变化，然后改变值。


- v-if和v-show区别

    > v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件。v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

- vue的生命周期
    >  Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom->渲染、更新->渲染、卸载等一系列过程，即 Vue 的生命周期。我们要知道 Vue 实例生命周期有8个，但是 keep-alive 有两个专属的生命周期，详解如下图。

    beforeCreate	组件实例被创建之初，组件的属性生效之前

    created	组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用

    beforeMount	在挂载开始之前被调用：相关的 render 函数首次被调用

    mounted	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子

    beforeUpdate	组件或实例数据更新之前调用，发生在虚拟 DOM 打补丁之前

    update	组件或实例数据更新之后

    activited	keep-alive 专属，组件被激活时调用

    deactivated	keep-alive 专属，组件被销毁时调用

    beforeDestory	组件或实例销毁前调用

    destoryed	组件或实例销毁后调用

- router 与 route 的区别
router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等

- vue-router 路由模式有几种？
 
    > vue-router有3种路由模式：hash，history，adstract.
    hash:使用URL hash值来做路由。支持所有浏览器，包括不支持HTML5 History Api 的浏览器。

    > hash实现原理：
    早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中的#后面的内容，
    特性：
    URL中的hash值只是客户端的一种状态，
    hash值的改变，都会在浏览器的访问历史中增加一个记录，
    可以通过a标签，并设置href属性，
    我们可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转（渲染）

    > history:依赖HTML5 History API和服务器配置，具体查看HTML5 History模式。

    > abstract:支持所有JavaScript运行环境，如Node.js服务器端，如果发现没有浏览器的API，路由会自动强制进入这个模式。

    > history实现原理：
    HTML5提供了History API来实现URL的变化

- vue-router 中常用的 hash 和 history 路由模式实现原理
    > 先理解hash 与 history 是什么？他们其实是路由的两种工作模式。vue默认为 hash 模式，转变为 history 模式方式如下图。▶️1. hash模式：❶地址中永远带着#号，不美观；❷若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合适；❸兼容性好。▶️2. history模式：❶地址干净，美观；❷兼容性和hash模式相比略差；❸应用部署上线时需要后端人员支持，解决刷新页面服务端404问题。

- vuex

- vue组件之间通信的几种方式

- vue3.0 特性

- Vue 项目进行哪些优化

- Vue Ssr Nuxt

# 六.react相关

# 七.TS相关

# 八.node相关


# 九.兼容问题
- 移动端适配1px问题

    1. 伪元素 + transform scaleY(.5) 
    2. border-image 
    3. background-image 
    4. box-shadow


# 其他
- 性能优化方法以及分类
- 数组去重
- 图片预加载
- 图片懒加载
- 虚拟长列表
- IntersectionObserver监听元素是否到可视区域,新api,兼容性比较大
- 宏任务,微任务
- 浏览器的event loop 和 node 的event loop
- webpack 热更新原理，是如何做到在不刷新 浏览器的前提下更新页面的
    1. 当修改了一个或多个文件； 
    2. 文件系统接收更改并通知 webpack； 
    3. webpack 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新； 
    4. HMR Server 使用 webSocket 通知 HMR runtime 需要更新，HMR 运行时 通过 HTTP 请求更新 jsonp； 
    5. HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整 个页面刷新。
- 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况
- int 字符串,数字,汉子,占的位数
- 进程,线程,守护进程,僵尸进程,孤儿进程
    1. 进程: 进程是操作系统资源分配的最小单元
    2. 线程: 线程是操作系统能够进行运算调度的最小单元。它被包含在进程中，是进程中实际运行的单位。一个进程中可以并发多个线程，每个线程执行不同的任务 。
    3. 僵尸进程： 一个父进程利用fork创建子进程，如果子进程退出，而父进程没有利用wait 或者  waitpid 来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。
    4. 孤儿进程：一个父进程退出， 而它的一个或几个子进程仍然还在运行，那么这些子进程就会变成孤儿进程，孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集的工作
- 堆,栈,队列,链表
- linux操作
- pm2部署常见问题

